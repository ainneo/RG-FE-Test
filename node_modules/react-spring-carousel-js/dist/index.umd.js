(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react/jsx-runtime'), require('react'), require('react-spring'), require('react-use-gesture'), require('rxjs'), require('screenfull')) :
  typeof define === 'function' && define.amd ? define(['exports', 'react/jsx-runtime', 'react', 'react-spring', 'react-use-gesture', 'rxjs', 'screenfull'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.ReactSpringCarousel = {}, global.jsxRuntime, global.React, global.reactSpring, global.reactUseGesture, global.rxjs, global.screenfull));
}(this, (function (exports, jsxRuntime, react, reactSpring, reactUseGesture, rxjs, screenfull) { 'use strict';

  function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

  var screenfull__default = /*#__PURE__*/_interopDefaultLegacy(screenfull);

  function useCustomEventsModule() {
      const eventsObserverRef = react.useRef(new rxjs.Subject());
      function useListenToCustomEvent(fn) {
          react.useEffect(() => {
              const subscribe = eventsObserverRef.current.subscribe(fn);
              return () => subscribe.unsubscribe();
          }, [fn]);
      }
      const emitObservable = data => {
          eventsObserverRef.current.next(data);
      };
      return {
          useListenToCustomEvent,
          emitObservable,
      };
  }

  function useFullscreenModule({ mainCarouselWrapperRef, emitObservable, handleResize, }) {
      const isFullscreen = react.useRef(false);
      react.useEffect(() => {
          function handleFullscreenChange() {
              if (document.fullscreenElement) {
                  setIsFullscreen(true);
                  emitObservable({
                      eventName: 'onFullscreenChange',
                      isFullscreen: true,
                  });
                  handleResize && handleResize();
              }
              if (!document.fullscreenElement) {
                  setIsFullscreen(false);
                  emitObservable({
                      eventName: 'onFullscreenChange',
                      isFullscreen: false,
                  });
                  handleResize && handleResize();
              }
          }
          if (screenfull__default['default'].isEnabled) {
              screenfull__default['default'].on('change', handleFullscreenChange);
              return () => {
                  if (screenfull__default['default'].isEnabled) {
                      screenfull__default['default'].off('change', handleFullscreenChange);
                  }
              };
          }
      });
      function setIsFullscreen(_isFullscreen) {
          isFullscreen.current = _isFullscreen;
      }
      function getIsFullscreen() {
          return isFullscreen.current;
      }
      function enterFullscreen(elementRef) {
          if (screenfull__default['default'].isEnabled) {
              screenfull__default['default'].request((elementRef || mainCarouselWrapperRef.current));
          }
      }
      function exitFullscreen() {
          screenfull__default['default'].isEnabled && screenfull__default['default'].exit();
      }
      return {
          enterFullscreen,
          exitFullscreen,
          getIsFullscreen,
      };
  }

  function useMount(callback) {
      const isMounted = react.useRef(false);
      react.useEffect(() => {
          if (!isMounted.current) {
              const clean = callback();
              isMounted.current = true;
              return () => {
                  clean && clean();
              };
          }
          // eslint-disable-next-line react-hooks/exhaustive-deps
      }, []);
  }
  function getIsBrowser() {
      return typeof window !== 'undefined';
  }

  function useThumbsModule({ items, withThumbs, thumbsSlideAxis = 'x', springConfig, thumbsWrapperRef, prepareThumbsData, }) {
      const internalThumbsWrapperRef = react.useRef(null);
      const [thumbListStyles, setThumbListStyles] = reactSpring.useSpring(() => ({
          [thumbsSlideAxis]: 0,
          config: springConfig,
      }));
      useMount(() => {
          if (withThumbs) {
              const missingThumbs = items.some(item => !item.renderThumb);
              if (missingThumbs) {
                  throw new Error('The renderThumb property is missing in one or more items. You need to add the renderThumb property to every item of the carousel when the prop withThumbs={true} or eventually set withThumbs={false}.');
              }
          }
      });
      function handleThumbsScroll(activeItem) {
          function getOffsetDirection() {
              return thumbsSlideAxis === 'x' ? 'offsetLeft' : 'offsetTop';
          }
          function getOffsetDimension() {
              return thumbsSlideAxis === 'x' ? 'offsetWidth' : 'offsetHeight';
          }
          function getScrollDirecton() {
              return thumbsSlideAxis === 'x' ? 'scrollLeft' : 'scrollTop';
          }
          function getThumbNode() {
              return internalThumbsWrapperRef.current.querySelector(`#thumb-${items[activeItem].id}`);
          }
          function getThumbOffsetPosition({ thumbNode, offsetDirection, offsetDimension, }) {
              return (thumbNode[offsetDirection] + thumbNode[offsetDimension] / 2);
          }
          function getThumbScrollDimension({ thumbWrapper, offsetDimension, }) {
              return thumbWrapper[offsetDimension] / 2;
          }
          function getScrollFromValue({ thumbWrapper, scrollDirection, }) {
              return thumbWrapper[scrollDirection];
          }
          function getScrollToValue({ thumbWrapper, thumbOffsetPosition, thumbScrollDimension, offsetDimension, }) {
              const scrollDimensionProperty = thumbsSlideAxis === 'x' ? 'scrollWidth' : 'scrollHeight';
              if (activeItem === items.length - 1 ||
                  thumbOffsetPosition - thumbScrollDimension >
                      thumbWrapper[scrollDimensionProperty] -
                          thumbWrapper[offsetDimension]) {
                  return (thumbWrapper[scrollDimensionProperty] -
                      thumbWrapper[offsetDimension]);
              }
              if (activeItem === 0) {
                  return 0;
              }
              return thumbOffsetPosition - thumbScrollDimension;
          }
          if (thumbsWrapperRef && thumbsWrapperRef.current) {
              internalThumbsWrapperRef.current = thumbsWrapperRef.current;
          }
          const thumbNode = getThumbNode();
          if (thumbNode) {
              const thumbWrapper = internalThumbsWrapperRef.current;
              const offsetDirection = getOffsetDirection();
              const offsetDimension = getOffsetDimension();
              const scrollDirection = getScrollDirecton();
              const thumbOffsetPosition = getThumbOffsetPosition({
                  thumbNode,
                  offsetDimension,
                  offsetDirection,
              });
              const thumbScrollDimension = getThumbScrollDimension({
                  thumbWrapper,
                  offsetDimension,
              });
              setThumbListStyles.start({
                  from: {
                      [thumbsSlideAxis]: getScrollFromValue({
                          thumbWrapper,
                          scrollDirection,
                      }),
                  },
                  to: {
                      [thumbsSlideAxis]: getScrollToValue({
                          thumbWrapper,
                          thumbOffsetPosition,
                          thumbScrollDimension,
                          offsetDimension,
                      }),
                  },
                  onChange: val => {
                      if (thumbsSlideAxis === 'x') {
                          // @ts-ignore
                          internalThumbsWrapperRef.current.scrollLeft = val.x;
                      }
                      else {
                          // @ts-ignore
                          internalThumbsWrapperRef.current.scrollTop = val.y;
                      }
                  },
              });
          }
      }
      function handlePrepareThumbsDate() {
          function getPreparedItems(_items) {
              return _items.map(i => ({
                  id: i.id,
                  renderThumb: i.renderThumb,
              }));
          }
          if (prepareThumbsData) {
              return prepareThumbsData(getPreparedItems(items));
          }
          return getPreparedItems(items);
      }
      function getScrollDirectionSpringValue() {
          if (thumbsSlideAxis === 'x') {
              return {
                  // @ts-ignore
                  scrollLeft: thumbListStyles.x,
              };
          }
          return {
              // @ts-ignore
              scrollTop: thumbListStyles.y,
          };
      }
      const thumbsFragment = withThumbs ? (jsxRuntime.jsx(reactSpring.animated.div, Object.assign({ ref: internalThumbsWrapperRef }, getScrollDirectionSpringValue(), { style: {
              display: 'flex',
              flex: 1,
              position: 'relative',
              flexDirection: thumbsSlideAxis === 'x' ? 'row' : 'column',
              ...(thumbsSlideAxis === 'x'
                  ? { overflowX: 'auto' }
                  : {
                      overflowY: 'auto',
                      maxHeight: '100%',
                  }),
          } }, { children: handlePrepareThumbsDate().map(({ id, renderThumb }) => {
              const thumbId = `thumb-${id}`;
              return (jsxRuntime.jsx("div", Object.assign({ id: thumbId }, { children: renderThumb }), thumbId));
          }) }), void 0)) : null;
      return {
          thumbsFragment,
          handleThumbsScroll,
      };
  }

  const UseSpringCarouselContext = react.createContext(undefined);
  function useSpringCarouselContext() {
      const context = react.useContext(UseSpringCarouselContext);
      if (!context) {
          throw new Error(`useSpringCarouselContext isn't being used within the useSringCarousel context; 
    use the context only inside a component that is rendered within the Carousel.`);
      }
      return context;
  }
  function useSpringCarousel({ items, withLoop = false, draggingSlideTreshold = 100, springConfig = reactSpring.config.default, shouldResizeOnWindowResize = true, withThumbs = false, enableThumbsWrapperScroll = true, carouselSlideAxis = 'x', thumbsSlideAxis = 'x', thumbsWrapperRef, prepareThumbsData, itemsPerSlide = 1, initialActiveItem = 0, initialStartingPosition = 'start', disableGestures = false, gutter = 0, adjacentItemsPx = 0, }) {
      function getItems() {
          if (withLoop) {
              return [...items, ...items, ...items];
          }
          return items;
      }
      const slideActionType = react.useRef('next');
      const internalItems = getItems();
      const activeItem = react.useRef(initialActiveItem);
      const mainCarouselWrapperRef = react.useRef(null);
      const carouselTrackWrapperRef = react.useRef(null);
      const isDragging = react.useRef(false);
      const isAnimating = react.useRef(false);
      const windowIsHidden = react.useRef(false);
      function getCarouselItem() {
          if (carouselTrackWrapperRef.current) {
              return carouselTrackWrapperRef.current.querySelector('.use-spring-carousel-item');
          }
          return null;
      }
      const [carouselStyles, setCarouselStyles] = reactSpring.useSpring(() => ({
          y: 0,
          x: 0,
          config: springConfig,
      }));
      const getSlideValue = react.useCallback(() => {
          if (!carouselTrackWrapperRef.current) {
              return 0;
          }
          const carouselItem = getCarouselItem();
          if (!carouselItem) {
              throw Error('No carousel items available!');
          }
          if (carouselSlideAxis === 'x') {
              return carouselItem.getBoundingClientRect().width + gutter;
          }
          return carouselItem.getBoundingClientRect().height + gutter;
      }, [carouselSlideAxis, gutter]);
      const adjustCarouselWrapperPosition = react.useCallback((ref) => {
          const positionProperty = carouselSlideAxis === 'x' ? 'left' : 'top';
          function getDefaultPositionValue() {
              return getSlideValue() * items.length;
          }
          function setPosition(v) {
              ref.style.top = '0px';
              ref.style.left = '0px';
              ref.style[positionProperty] = `-${v - adjacentItemsPx}px`;
          }
          function setStartPosition() {
              setPosition(getDefaultPositionValue());
          }
          function setCenterPosition() {
              setPosition(getDefaultPositionValue() -
                  getSlideValue() * Math.round((itemsPerSlide - 1) / 2));
          }
          function setEndPosition() {
              setPosition(getDefaultPositionValue() -
                  getSlideValue() * Math.round(itemsPerSlide - 1));
          }
          if (itemsPerSlide > 1) {
              switch (initialStartingPosition) {
                  default:
                  case 'start': {
                      setStartPosition();
                      break;
                  }
                  case 'center': {
                      setCenterPosition();
                      break;
                  }
                  case 'end': {
                      setEndPosition();
                      break;
                  }
              }
          }
          else {
              setStartPosition();
          }
      }, [
          carouselSlideAxis,
          getSlideValue,
          initialStartingPosition,
          items.length,
          itemsPerSlide,
          adjacentItemsPx,
      ]);
      const handleResize = react.useCallback(() => {
          setCarouselStyles.start({
              immediate: true,
              x: 0,
              y: 0,
          });
          setCarouselStyles.start({
              immediate: true,
              [carouselSlideAxis]: -(getSlideValue() * getCurrentActiveItem()),
          });
          if (withLoop) {
              adjustCarouselWrapperPosition(carouselTrackWrapperRef.current);
          }
      }, [
          adjustCarouselWrapperPosition,
          carouselSlideAxis,
          getSlideValue,
          setCarouselStyles,
          withLoop,
      ]);
      // Custom modules
      const { useListenToCustomEvent, emitObservable, } = useCustomEventsModule();
      const { enterFullscreen, exitFullscreen, getIsFullscreen, } = useFullscreenModule({
          mainCarouselWrapperRef,
          emitObservable,
          handleResize,
      });
      const { thumbsFragment: _thumbsFragment, handleThumbsScroll, } = useThumbsModule({
          withThumbs,
          items,
          thumbsSlideAxis,
          springConfig,
          thumbsWrapperRef,
          prepareThumbsData,
      });
      const bindDrag = reactUseGesture.useDrag(props => {
          const isDragging = props.dragging;
          const movement = props.movement[carouselSlideAxis === 'x' ? 0 : 1];
          const currentSlidedValue = -(getSlideValue() * getCurrentActiveItem());
          function resetAnimation() {
              setCarouselStyles.start({
                  [carouselSlideAxis]: currentSlidedValue,
              });
          }
          if (isDragging) {
              setCarouselStyles.start({
                  [carouselSlideAxis]: currentSlidedValue + movement,
              });
              setIsDragging(true);
              emitObservable({
                  eventName: 'onDrag',
                  ...props,
              });
              const prevItemTreshold = movement > draggingSlideTreshold;
              const nextItemTreshold = movement < -draggingSlideTreshold;
              if (nextItemTreshold) {
                  if (!withLoop && getIsLastItem()) {
                      resetAnimation();
                  }
                  else {
                      slideToNextItem();
                  }
                  props.cancel();
              }
              else if (prevItemTreshold) {
                  if (!withLoop && getIsFirstItem()) {
                      resetAnimation();
                  }
                  else {
                      slideToPrevItem();
                  }
                  props.cancel();
              }
          }
          if (props.last) {
              resetAnimation();
          }
      }, {
          enabled: !disableGestures,
      });
      // Perform some check on first mount
      useMount(() => {
          if (!Number.isInteger(itemsPerSlide)) {
              throw new Error(`itemsPerSlide should be an integer.`);
          }
          if (itemsPerSlide > items.length) {
              throw new Error(`The itemsPerSlide prop can't be greater than the total length of the items you provide.`);
          }
          if (itemsPerSlide < 1) {
              throw new Error(`The itemsPerSlide prop can't be less than 1.`);
          }
          if (!shouldResizeOnWindowResize) {
              console.warn('You set shouldResizeOnWindowResize={false}; be aware that the carousel could behave in a strange way if you also use the fullscreen functionality or if you change the mobile orientation.');
          }
          if (initialActiveItem < 0) {
              console.warn('The initialActiveItem cannot be less than 0.');
          }
          if (initialActiveItem > items.length) {
              console.warn('The initialActiveItem cannot be greater than the total length of the items you provide.');
          }
      });
      useMount(() => {
          function handleVisibilityChange() {
              if (document.hidden) {
                  windowIsHidden.current = true;
              }
              else {
                  windowIsHidden.current = false;
              }
          }
          if (getIsBrowser()) {
              document.addEventListener('visibilitychange', handleVisibilityChange);
              return () => {
                  document.removeEventListener('visibilitychange', handleVisibilityChange);
              };
          }
      });
      react.useEffect(() => {
          if (shouldResizeOnWindowResize) {
              window.addEventListener('resize', handleResize);
              return () => {
                  window.removeEventListener('resize', handleResize);
              };
          }
      }, [handleResize, shouldResizeOnWindowResize]);
      react.useEffect(() => {
          if (carouselTrackWrapperRef.current) {
              if (carouselSlideAxis === 'x') {
                  carouselTrackWrapperRef.current.style.top = '0px';
              }
              if (carouselSlideAxis === 'y') {
                  carouselTrackWrapperRef.current.style.left = '0px';
              }
          }
      }, [carouselSlideAxis]);
      useMount(() => {
          if (initialActiveItem > 0 && initialActiveItem <= items.length) {
              slideToItem({
                  to: initialActiveItem,
                  immediate: true,
              });
              setActiveItem(initialActiveItem);
          }
      });
      function setSlideActionType(type) {
          slideActionType.current = type;
      }
      function getSlideActionType() {
          return slideActionType.current;
      }
      function setActiveItem(newItem) {
          activeItem.current = newItem;
      }
      function getCurrentActiveItem() {
          return activeItem.current;
      }
      function getIsAnimating() {
          return isAnimating.current;
      }
      function setIsAnimating(val) {
          isAnimating.current = val;
      }
      function setIsDragging(val) {
          isDragging.current = val;
      }
      function getIsDragging() {
          return isDragging.current;
      }
      function getPrevItem() {
          const currentActiveItem = getCurrentActiveItem();
          if (currentActiveItem === 0) {
              return items.length - 1;
          }
          return currentActiveItem - 1;
      }
      function getNextItem() {
          const currentActiveItem = getCurrentActiveItem();
          if (currentActiveItem === items.length - 1) {
              return 0;
          }
          return currentActiveItem + 1;
      }
      function getIsNextItem(id) {
          const itemIndex = findItemIndex(id);
          const activeItem = getCurrentActiveItem();
          if (withLoop && activeItem === items.length - 1) {
              return itemIndex === 0;
          }
          return itemIndex === activeItem + 1;
      }
      function getIsPrevItem(id) {
          const itemIndex = findItemIndex(id);
          const activeItem = getCurrentActiveItem();
          if (withLoop && activeItem === 0) {
              return itemIndex === items.length - 1;
          }
          return itemIndex === activeItem - 1;
      }
      function findItemIndex(id) {
          return items.findIndex(item => item.id === id);
      }
      function slideToItem({ from, to, immediate = false, onRest = () => { }, }) {
          if (!immediate) {
              setActiveItem(to);
              setIsAnimating(true);
              emitObservable({
                  eventName: 'onSlideStartChange',
                  nextItem: to,
                  slideActionType: getSlideActionType(),
              });
          }
          function getFromValue() {
              if (from) {
                  return {
                      from: {
                          [carouselSlideAxis]: from,
                      },
                  };
              }
              return {};
          }
          setCarouselStyles.start({
              ...getFromValue(),
              to: {
                  [carouselSlideAxis]: -(getSlideValue() * to),
              },
              immediate,
              onRest: (val) => {
                  if (val.finished) {
                      setIsDragging(false);
                      setIsAnimating(false);
                      onRest();
                      if (!immediate) {
                          emitObservable({
                              eventName: 'onSlideChange',
                              currentItem: getCurrentActiveItem(),
                              slideActionType: getSlideActionType(),
                          });
                      }
                  }
              },
          });
          if (enableThumbsWrapperScroll && withThumbs && !immediate) {
              handleThumbsScroll(to);
          }
      }
      function getWrapperFromValue(element) {
          if (element.style.transform === 'none') {
              return 0;
          }
          const values = element.style.transform.split(/\w+\(|\);?/);
          return Number(values[1]
              .split(/,\s?/g)[carouselSlideAxis === 'x' ? 0 : 1].replace('px', ''));
      }
      function getIsFirstItem() {
          return getCurrentActiveItem() === 0;
      }
      function getIsLastItem() {
          return getCurrentActiveItem() === items.length - 1;
      }
      function slideToPrevItem() {
          if ((!withLoop && getCurrentActiveItem() === 0) ||
              windowIsHidden.current) {
              return;
          }
          setSlideActionType('prev');
          if (getIsFirstItem()) {
              slideToItem({
                  from: -(Math.abs(getWrapperFromValue(carouselTrackWrapperRef.current)) +
                      getSlideValue() * items.length),
                  to: items.length - 1,
              });
          }
          else {
              slideToItem({
                  to: getPrevItem(),
              });
          }
      }
      function slideToNextItem() {
          if ((!withLoop &&
              getCurrentActiveItem() === internalItems.length - 1) ||
              windowIsHidden.current) {
              return;
          }
          setSlideActionType('next');
          if (getIsLastItem()) {
              slideToItem({
                  from: getWrapperFromValue(carouselTrackWrapperRef.current) +
                      getSlideValue() * items.length,
                  to: 0,
              });
          }
          else {
              slideToItem({
                  to: getNextItem(),
              });
          }
      }
      function _slideToItem(item) {
          let itemIndex = 0;
          if (typeof item === 'string') {
              itemIndex = items.findIndex(_item => _item.id === item);
          }
          else {
              itemIndex = item;
          }
          if (itemIndex >= items.length) {
              throw Error(`The item you want to slide to doesn't exist. This could be due to the fact that 
        you provide a wrong id or a higher numeric index.`);
          }
          if (itemIndex === getCurrentActiveItem()) {
              return;
          }
          const currentItem = findItemIndex(items[getCurrentActiveItem()].id);
          const newActiveItem = findItemIndex(items[itemIndex].id);
          if (newActiveItem > currentItem) {
              setSlideActionType('next');
          }
          else {
              setSlideActionType('prev');
          }
          slideToItem({
              to: itemIndex,
          });
      }
      const contextProps = {
          useListenToCustomEvent,
          getIsFullscreen,
          enterFullscreen,
          exitFullscreen,
          getIsAnimating,
          getIsDragging,
          getIsNextItem,
          getIsPrevItem,
          slideToPrevItem,
          slideToNextItem,
          slideToItem: _slideToItem,
          getIsActiveItem: id => {
              return findItemIndex(id) === getCurrentActiveItem();
          },
          getCurrentActiveItem: () => ({
              id: items[getCurrentActiveItem()].id,
              index: getCurrentActiveItem(),
          }),
      };
      function getItemWidthValue() {
          return `repeat(${internalItems.length}, calc(calc(100% - ${gutter * (itemsPerSlide - 1)}px) / ${itemsPerSlide}))`;
      }
      function getPercentageValue() {
          return `calc(100% - ${adjacentItemsPx * 2}px)`;
      }
      const carouselFragment = (jsxRuntime.jsx(UseSpringCarouselContext.Provider, Object.assign({ value: contextProps }, { children: jsxRuntime.jsx("div", Object.assign({ ref: mainCarouselWrapperRef, "data-testid": "use-spring-carousel-wrapper", style: {
                  display: 'flex',
                  position: 'relative',
                  width: '100%',
                  height: '100%',
                  overflow: 'hidden',
              } }, { children: jsxRuntime.jsx(reactSpring.animated.div, Object.assign({}, bindDrag(), { "data-testid": "use-spring-carousel-animated-wrapper", style: {
                      display: 'grid',
                      gridGap: `${gutter}px`,
                      [carouselSlideAxis === 'x'
                          ? 'gridTemplateColumns'
                          : 'gridTemplateRows']: getItemWidthValue(),
                      top: 0,
                      left: 0,
                      width: carouselSlideAxis === 'x'
                          ? getPercentageValue()
                          : '100%',
                      height: carouselSlideAxis === 'y'
                          ? getPercentageValue()
                          : '100%',
                      position: 'relative',
                      ...carouselStyles,
                  }, ref: ref => {
                      if (ref) {
                          carouselTrackWrapperRef.current = ref;
                          if (withLoop) {
                              adjustCarouselWrapperPosition(ref);
                          }
                      }
                  } }, { children: internalItems.map(({ id, renderItem }, index) => {
                      return (jsxRuntime.jsx("div", Object.assign({ className: "use-spring-carousel-item", "data-testid": "use-spring-carousel-item-wrapper", style: {
                              display: 'flex',
                              position: 'relative',
                          } }, { children: renderItem }), `${id}-${index}`));
                  }) }), void 0) }), void 0) }), void 0));
      const thumbsFragment = (jsxRuntime.jsx(UseSpringCarouselContext.Provider, Object.assign({ value: contextProps }, { children: _thumbsFragment }), void 0));
      return {
          carouselFragment,
          thumbsFragment,
          ...contextProps,
      };
  }

  const UseTransitionCarouselContext = react.createContext(undefined);
  function useTransitionCarouselContext() {
      const context = react.useContext(UseTransitionCarouselContext);
      if (!context) {
          throw new Error(`useTransitionCarouselContext isn't being used within the useTransitionCarousel context; 
    use the context only inside a component that is rendered within the Carousel.`);
      }
      return context;
  }
  function useTransitionCarousel({ items, withLoop = false, withThumbs = false, springConfig = reactSpring.config.default, thumbsSlideAxis = 'x', enableThumbsWrapperScroll = true, draggingSlideTreshold = 50, prepareThumbsData, toPrevItemSpringProps, toNextItemSpringProps, disableGestures = false, springAnimationProps = {
      initial: {
          opacity: 1,
          position: 'relative',
      },
      from: {
          opacity: 0,
          position: 'absolute',
      },
      enter: {
          opacity: 1,
          position: 'relative',
      },
      leave: {
          opacity: 0,
          position: 'absolute',
      },
  }, }) {
      const slideActionType = react.useRef('next');
      const mainCarouselWrapperRef = react.useRef(null);
      const isAnimating = react.useRef(false);
      const [activeItem, setActiveItem] = react.useState(0);
      const { emitObservable, useListenToCustomEvent, } = useCustomEventsModule();
      const { enterFullscreen, exitFullscreen, getIsFullscreen, } = useFullscreenModule({
          emitObservable,
          mainCarouselWrapperRef,
      });
      const { thumbsFragment: _thumbsFragment, handleThumbsScroll, } = useThumbsModule({
          items,
          withThumbs,
          thumbsSlideAxis,
          springConfig,
          prepareThumbsData,
      });
      const bindSwipe = reactUseGesture.useDrag(({ last, movement: [mx] }) => {
          if (getIsAnimating()) {
              return;
          }
          if (last) {
              const prevItemTreshold = mx > draggingSlideTreshold;
              const nextItemTreshold = mx < -draggingSlideTreshold;
              const isFirstItem = activeItem === 0;
              const isLastItem = activeItem === items.length - 1;
              if (nextItemTreshold) {
                  if (!withLoop && isLastItem) {
                      return;
                  }
                  slideToNextItem();
                  emitObservable({
                      eventName: 'onLeftSwipe',
                  });
              }
              else if (prevItemTreshold) {
                  if (!withLoop && isFirstItem) {
                      return;
                  }
                  slideToPrevItem();
                  emitObservable({
                      eventName: 'onRightSwipe',
                  });
              }
          }
      }, {
          enabled: !disableGestures,
      });
      function getTransitionConfig() {
          const slideActionType = getSlideActionType();
          if (slideActionType === 'prev' && toPrevItemSpringProps) {
              return {
                  initial: {
                      ...springAnimationProps.initial,
                  },
                  from: {
                      ...toPrevItemSpringProps.from,
                  },
                  enter: {
                      ...toPrevItemSpringProps.enter,
                  },
                  leave: {
                      ...toPrevItemSpringProps.leave,
                  },
              };
          }
          if (slideActionType === 'next' && toNextItemSpringProps) {
              return {
                  initial: {
                      ...springAnimationProps.initial,
                  },
                  from: {
                      ...toNextItemSpringProps.from,
                  },
                  enter: {
                      ...toNextItemSpringProps.enter,
                  },
                  leave: {
                      ...toNextItemSpringProps.leave,
                  },
              };
          }
          return {
              initial: {
                  ...springAnimationProps.initial,
              },
              from: {
                  ...springAnimationProps.from,
              },
              enter: {
                  ...springAnimationProps.enter,
              },
              leave: {
                  ...springAnimationProps.leave,
              },
          };
      }
      const transitions = reactSpring.useTransition(activeItem, {
          config: springConfig,
          ...getTransitionConfig(),
          onStart: () => setIsAnimating(true),
          keys: null,
          onRest: val => {
              if (val.finished) {
                  setIsAnimating(false);
                  emitObservable({
                      eventName: 'onSlideChange',
                      currentItem: activeItem,
                      slideActionType: getSlideActionType(),
                  });
              }
          },
      });
      const itemsFragment = transitions((styles, item) => (jsxRuntime.jsx(reactSpring.animated.div, Object.assign({ style: {
              ...styles,
              flex: '1 0 100%',
              width: '100%',
              height: '100%',
          } }, { children: items[item].renderItem }), void 0)));
      function getIsAnimating() {
          return isAnimating.current;
      }
      function setIsAnimating(val) {
          isAnimating.current = val;
      }
      function setSlideActionType(type) {
          slideActionType.current = type;
      }
      function getSlideActionType() {
          return slideActionType.current;
      }
      function slideToItem(item) {
          let itemIndex = 0;
          if (typeof item === 'string') {
              itemIndex = items.findIndex(_item => _item.id === item);
          }
          else {
              itemIndex = item;
          }
          if (itemIndex >= items.length) {
              throw Error(`The item you want to slide to doesn't exist. This could be due to the fact that 
        you provide a wrong id or a higher numeric index.`);
          }
          if (itemIndex === activeItem) {
              return;
          }
          const currentItem = findItemIndex(items[activeItem].id);
          const newActiveItem = findItemIndex(items[itemIndex].id);
          emitObservable({
              eventName: 'onSlideStartChange',
              nextItem: newActiveItem,
              slideActionType: getSlideActionType(),
          });
          if (newActiveItem > currentItem) {
              setSlideActionType('next');
          }
          else {
              setSlideActionType('prev');
          }
          setActiveItem(itemIndex);
          if (enableThumbsWrapperScroll && withThumbs) {
              handleThumbsScroll(itemIndex);
          }
      }
      function slideToNextItem() {
          const isLastItem = activeItem === items.length - 1;
          if (withLoop) {
              setSlideActionType('next');
              if (isLastItem) {
                  emitObservable({
                      eventName: 'onSlideStartChange',
                      nextItem: 0,
                      slideActionType: getSlideActionType(),
                  });
                  setActiveItem(0);
              }
              else {
                  emitObservable({
                      eventName: 'onSlideStartChange',
                      nextItem: activeItem + 1,
                      slideActionType: getSlideActionType(),
                  });
                  setActiveItem(activeItem + 1);
              }
          }
          else {
              if (!isLastItem) {
                  emitObservable({
                      eventName: 'onSlideStartChange',
                      nextItem: activeItem + 1,
                      slideActionType: getSlideActionType(),
                  });
                  setSlideActionType('next');
                  setActiveItem(activeItem + 1);
              }
          }
      }
      function slideToPrevItem() {
          const isFirstItem = activeItem === 0;
          if (withLoop) {
              setSlideActionType('prev');
              if (isFirstItem) {
                  emitObservable({
                      eventName: 'onSlideStartChange',
                      nextItem: items.length - 1,
                      slideActionType: getSlideActionType(),
                  });
                  setActiveItem(items.length - 1);
              }
              else {
                  emitObservable({
                      eventName: 'onSlideStartChange',
                      nextItem: activeItem - 1,
                      slideActionType: getSlideActionType(),
                  });
                  setActiveItem(activeItem - 1);
              }
          }
          else {
              if (!isFirstItem) {
                  setSlideActionType('prev');
                  emitObservable({
                      eventName: 'onSlideStartChange',
                      nextItem: activeItem - 1,
                      slideActionType: getSlideActionType(),
                  });
                  setActiveItem(activeItem - 1);
              }
          }
      }
      function findItemIndex(id) {
          return items.findIndex(item => item.id === id);
      }
      function getIsNextItem(id) {
          const itemIndex = findItemIndex(id);
          if (withLoop && activeItem === items.length - 1) {
              return itemIndex === 0;
          }
          return itemIndex === activeItem + 1;
      }
      function getIsPrevItem(id) {
          const itemIndex = findItemIndex(id);
          if (withLoop && activeItem === 0) {
              return itemIndex === items.length - 1;
          }
          return itemIndex === activeItem - 1;
      }
      const contextProps = {
          activeItem,
          slideToItem,
          slideToNextItem,
          slideToPrevItem,
          enterFullscreen,
          exitFullscreen,
          useListenToCustomEvent,
          getIsNextItem,
          getIsPrevItem,
          getIsAnimating,
          getIsFullscreen,
          getIsActiveItem: id => {
              return findItemIndex(id) === activeItem;
          },
          getCurrentActiveItem: () => ({
              id: items[activeItem].id,
              index: activeItem,
          }),
      };
      const carouselFragment = (jsxRuntime.jsx(UseTransitionCarouselContext.Provider, Object.assign({ value: contextProps }, { children: jsxRuntime.jsx("div", Object.assign({ ref: mainCarouselWrapperRef }, bindSwipe(), { style: {
                  display: 'flex',
                  position: 'relative',
                  width: '100%',
                  height: '100%',
                  overflow: 'hidden',
              } }, { children: itemsFragment }), void 0) }), void 0));
      const thumbsFragment = (jsxRuntime.jsx(UseTransitionCarouselContext.Provider, Object.assign({ value: contextProps }, { children: _thumbsFragment }), void 0));
      return {
          carouselFragment,
          thumbsFragment,
          ...contextProps,
      };
  }

  exports.useSpringCarousel = useSpringCarousel;
  exports.useSpringCarouselContext = useSpringCarouselContext;
  exports.useTransitionCarousel = useTransitionCarousel;
  exports.useTransitionCarouselContext = useTransitionCarouselContext;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=index.umd.js.map
